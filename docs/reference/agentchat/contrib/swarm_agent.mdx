---
sidebarTitle: swarm_agent
title: autogen.agentchat.contrib.swarm_agent
---

## Functions

<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>
#### a_initiate_swarm_chat
<a href="#autogen.agentchat.contrib.swarm_agent..a_initiate_swarm_chat" class="headerlink" title="Permanent link"></a>

```python
a_initiate_swarm_chat(
    initial_agent: SwarmAgent,
    messages: list[dict[str, typing.Any]] | str,
    agents: list['SwarmAgent'],
    user_agent: autogen.agentchat.user_proxy_agent.UserProxyAgent | None = None,
    max_rounds: int = 20,
    context_variables: dict[str, typing.Any] | None = None,
    after_work: autogen.agentchat.contrib.swarm_agent.AfterWorkOption | Callable | None = AFTER_WORK(agent=&lt;AfterWorkOption.TERMINATE: 'TERMINATE'>)
) -> tuple[autogen.agentchat.chat.ChatResult, dict[str, typing.Any], 'SwarmAgent']
```

    Initialize and run a swarm chat asynchronously

<b>Parameters:</b>
| Name | Description |
|--|--|
| `initial_agent` | The first receiving agent of the conversation.<br/><br/>**Type:** `SwarmAgent` |
| `messages` | Initial message(s).<br/><br/>**Type:** `list[dict[str, typing.Any]] \| str` |
| `agents` | List of swarm agents.<br/><br/>**Type:** `list['SwarmAgent']` |
| `user_agent` | Optional user proxy agent for falling back to.<br/><br/>**Type:** `autogen.agentchat.user_proxy_agent.UserProxyAgent \| None`<br/><br/>**Default:** None |
| `max_rounds` | Maximum number of conversation rounds.<br/><br/>**Type:** `int`<br/><br/>**Default:** 20 |
| `context_variables` | Starting context variables.<br/><br/>**Type:** `dict[str, typing.Any] \| None`<br/><br/>**Default:** None |
| `after_work` | Method to handle conversation continuation when an agent doesn't select the next agent.<br/><br/>If no agent is selected and no tool calls are output, we will use this method to determine the next agent.<br/><br/>Must be a AFTER_WORK instance (which is a dataclass accepting a SwarmAgent, AfterWorkOption, A str (of the AfterWorkOption)) or a callable.<br/><br/>AfterWorkOption: - TERMINATE (Default): Terminate the conversation.<br/><br/>- REVERT_TO_USER : Revert to the user agent if a user agent is provided.<br/><br/>If not provided, terminate the conversation.<br/><br/>- STAY : Stay with the last speaker.<br/><br/>Callable: A custom function that takes the current agent, messages, and groupchat as arguments and returns an AfterWorkOption or a SwarmAgent (by reference or string name).<br/><br/>```python def custom_afterwork_func(last_speaker: SwarmAgent, messages: List[Dict[str, Any]], groupchat: GroupChat) -> Union[AfterWorkOption, SwarmAgent, str]: ```<br/><br/>**Type:** `autogen.agentchat.contrib.swarm_agent.AfterWorkOption \| Callable \| None = AFTER_WORK(agent`<br/><br/>**Default:** &lt;AfterWorkOption.TERMINATE |

<b>Returns:</b>
| Type | Description |
|--|--|
| `tuple[autogen.agentchat.chat.ChatResult, dict[str, typing.Any], 'SwarmAgent']` | ChatResult: Conversations chat history. Dict[str, Any]: Updated Context variables. SwarmAgent: Last speaker. |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>
#### create_swarm_transition
<a href="#autogen.agentchat.contrib.swarm_agent..create_swarm_transition" class="headerlink" title="Permanent link"></a>

```python
create_swarm_transition(
    initial_agent: SwarmAgent,
    tool_execution: SwarmAgent,
    swarm_agent_names: list[str],
    user_agent: autogen.agentchat.user_proxy_agent.UserProxyAgent | None,
    swarm_after_work: autogen.agentchat.contrib.swarm_agent.AfterWorkOption | Callable | None
) -> Callable[[autogen.agentchat.contrib.swarm_agent.SwarmAgent, autogen.agentchat.groupchat.GroupChat], autogen.agentchat.agent.Agent | None]
```

    Creates a transition function for swarm chat with enclosed state for the use_initial_agent.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `initial_agent` | The first agent to speak<br/><br/>**Type:** `SwarmAgent` |
| `tool_execution` | The tool execution agent<br/><br/>**Type:** `SwarmAgent` |
| `swarm_agent_names` | List of all agent names<br/><br/>**Type:** `list[str]` |
| `user_agent` | Optional user proxy agent<br/><br/>**Type:** `autogen.agentchat.user_proxy_agent.UserProxyAgent \| None` |
| `swarm_after_work` | Swarm-level after work<br/><br/>**Type:** `autogen.agentchat.contrib.swarm_agent.AfterWorkOption \| Callable \| None` |

<b>Returns:</b>
| Type | Description |
|--|--|
| `Callable[[autogen.agentchat.contrib.swarm_agent.SwarmAgent, autogen.agentchat.groupchat.GroupChat], autogen.agentchat.agent.Agent \| None]` | Callable transition function (for sync and async swarm chats) |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>
#### initiate_swarm_chat
<a href="#autogen.agentchat.contrib.swarm_agent..initiate_swarm_chat" class="headerlink" title="Permanent link"></a>

```python
initiate_swarm_chat(
    initial_agent: SwarmAgent,
    messages: list[dict[str, typing.Any]] | str,
    agents: list['SwarmAgent'],
    user_agent: autogen.agentchat.user_proxy_agent.UserProxyAgent | None = None,
    max_rounds: int = 20,
    context_variables: dict[str, typing.Any] | None = None,
    after_work: autogen.agentchat.contrib.swarm_agent.AfterWorkOption | Callable | None = AFTER_WORK(agent=&lt;AfterWorkOption.TERMINATE: 'TERMINATE'>)
) -> tuple[autogen.agentchat.chat.ChatResult, dict[str, typing.Any], 'SwarmAgent']
```

    Initialize and run a swarm chat

<b>Parameters:</b>
| Name | Description |
|--|--|
| `initial_agent` | The first receiving agent of the conversation.<br/><br/>**Type:** `SwarmAgent` |
| `messages` | Initial message(s).<br/><br/>**Type:** `list[dict[str, typing.Any]] \| str` |
| `agents` | List of swarm agents.<br/><br/>**Type:** `list['SwarmAgent']` |
| `user_agent` | Optional user proxy agent for falling back to.<br/><br/>**Type:** `autogen.agentchat.user_proxy_agent.UserProxyAgent \| None`<br/><br/>**Default:** None |
| `max_rounds` | Maximum number of conversation rounds.<br/><br/>**Type:** `int`<br/><br/>**Default:** 20 |
| `context_variables` | Starting context variables.<br/><br/>**Type:** `dict[str, typing.Any] \| None`<br/><br/>**Default:** None |
| `after_work` | Method to handle conversation continuation when an agent doesn't select the next agent.<br/><br/>If no agent is selected and no tool calls are output, we will use this method to determine the next agent.<br/><br/>Must be a AFTER_WORK instance (which is a dataclass accepting a SwarmAgent, AfterWorkOption, A str (of the AfterWorkOption)) or a callable.<br/><br/>AfterWorkOption: - TERMINATE (Default): Terminate the conversation.<br/><br/>- REVERT_TO_USER : Revert to the user agent if a user agent is provided.<br/><br/>If not provided, terminate the conversation.<br/><br/>- STAY : Stay with the last speaker.<br/><br/>Callable: A custom function that takes the current agent, messages, and groupchat as arguments and returns an AfterWorkOption or a SwarmAgent (by reference or string name).<br/><br/>```python def custom_afterwork_func(last_speaker: SwarmAgent, messages: List[Dict[str, Any]], groupchat: GroupChat) -> Union[AfterWorkOption, SwarmAgent, str]: ```<br/><br/>**Type:** `autogen.agentchat.contrib.swarm_agent.AfterWorkOption \| Callable \| None = AFTER_WORK(agent`<br/><br/>**Default:** &lt;AfterWorkOption.TERMINATE |

<b>Returns:</b>
| Type | Description |
|--|--|
| `tuple[autogen.agentchat.chat.ChatResult, dict[str, typing.Any], 'SwarmAgent']` | ChatResult: Conversations chat history. Dict[str, Any]: Updated Context variables. SwarmAgent: Last speaker. |

<br />

    <h2 id="autogen.agentchat.contrib.swarm_agent.AFTER_WORK" class="doc doc-heading">
        <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
        <span class="doc doc-object-name doc-class-name">AFTER_WORK</span>
        <a href="#autogen.agentchat.contrib.swarm_agent.AFTER_WORK" class="headerlink" title="Permanent link"></a>
    </h2>

```python
AFTER_WORK(agent: autogen.agentchat.contrib.swarm_agent.AfterWorkOption | ForwardRef('SwarmAgent') | str | Callable)
```

    Handles the next step in the conversation when an agent doesn't suggest a tool call or a handoff

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agent` | The agent to hand off to or the after work option.<br/><br/>Can be a SwarmAgent, a string name of a SwarmAgent, an AfterWorkOption, or a Callable.<br/><br/>The Callable signature is: def my_after_work_func(last_speaker: SwarmAgent, messages: List[Dict[str, Any]], groupchat: GroupChat) -> Union[AfterWorkOption, SwarmAgent, str]:<br/><br/>**Type:** `autogen.agentchat.contrib.swarm_agent.AfterWorkOption \| ForwardRef('SwarmAgent') \| str \| Callable` |

### Class Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### agent
<a href="#autogen.agentchat.contrib.swarm_agent.AFTER_WORK.agent" class="headerlink" title="Permanent link"></a>

    <br />

    <h2 id="autogen.agentchat.contrib.swarm_agent.AfterWorkOption" class="doc doc-heading">
        <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
        <span class="doc doc-object-name doc-class-name">AfterWorkOption</span>
        <a href="#autogen.agentchat.contrib.swarm_agent.AfterWorkOption" class="headerlink" title="Permanent link"></a>
    </h2>

```python
AfterWorkOption(
    value,
    names=None,
    *,
    module=None,
    qualname=None,
    type=None,
    start=1
)
```

    An enumeration.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `value` |  |
| `names=None` |  |
| `module=None` |  |
| `qualname=None` |  |
| `type=None` |  |
| `start=1` |  |

### Class Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### REVERT_TO_USER
<a href="#autogen.agentchat.contrib.swarm_agent.AfterWorkOption.REVERT_TO_USER" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### STAY
<a href="#autogen.agentchat.contrib.swarm_agent.AfterWorkOption.STAY" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### SWARM_MANAGER
<a href="#autogen.agentchat.contrib.swarm_agent.AfterWorkOption.SWARM_MANAGER" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### TERMINATE
<a href="#autogen.agentchat.contrib.swarm_agent.AfterWorkOption.TERMINATE" class="headerlink" title="Permanent link"></a>

    <br />

    <h2 id="autogen.agentchat.contrib.swarm_agent.ON_CONDITION" class="doc doc-heading">
        <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
        <span class="doc doc-object-name doc-class-name">ON_CONDITION</span>
        <a href="#autogen.agentchat.contrib.swarm_agent.ON_CONDITION" class="headerlink" title="Permanent link"></a>
    </h2>

```python
ON_CONDITION(
    target: ForwardRef('SwarmAgent') | dict[str, typing.Any] = None,
    condition: str = '',
    available: str | Callable | None = None
)
```

    Defines a condition for transitioning to another agent or nested chats

<b>Parameters:</b>
| Name | Description |
|--|--|
| `target` | The agent to hand off to or the nested chat configuration.<br/><br/>Can be a SwarmAgent or a Dict.<br/><br/>If a Dict, it should follow the convention of the nested chat configuration, with the exception of a carryover configuration which is unique to Swarms.<br/><br/>Swarm Nested chat documentation: https://docs.ag2.ai/docs/topics/swarm#registering-handoffs-to-a-nested-chat<br/><br/>**Type:** `ForwardRef('SwarmAgent') \| dict[str, typing.Any]`<br/><br/>**Default:** None |
| `condition` | The condition for transitioning to the target agent, evaluated by the LLM to determine whether to call the underlying function/tool which does the transition.<br/><br/>**Type:** `str`<br/><br/>**Default:** '' |
| `available` | Optional condition to determine if this ON_CONDITION is available.<br/><br/>Can be a Callable or a string.<br/><br/>If a string, it will look up the value of the context variable with that name, which should be a bool.<br/><br/>**Type:** `str \| Callable \| None`<br/><br/>**Default:** None |

### Class Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### available
<a href="#autogen.agentchat.contrib.swarm_agent.ON_CONDITION.available" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### condition
<a href="#autogen.agentchat.contrib.swarm_agent.ON_CONDITION.condition" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### target
<a href="#autogen.agentchat.contrib.swarm_agent.ON_CONDITION.target" class="headerlink" title="Permanent link"></a>

    <br />

    <h2 id="autogen.agentchat.contrib.swarm_agent.SwarmAgent" class="doc doc-heading">
        <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
        <span class="doc doc-object-name doc-class-name">SwarmAgent</span>
        <a href="#autogen.agentchat.contrib.swarm_agent.SwarmAgent" class="headerlink" title="Permanent link"></a>
    </h2>

```python
SwarmAgent(
    name: str,
    system_message: str | None = 'You are a helpful AI Assistant.',
    llm_config: dict | Literal[False] | None = None,
    functions: list[typing.Callable] | Callable = None,
    is_termination_msg: Callable[[dict], bool] | None = None,
    max_consecutive_auto_reply: int | None = None,
    human_input_mode: Literal['ALWAYS', 'NEVER', 'TERMINATE'] = 'NEVER',
    description: str | None = None,
    code_execution_config=False,
    update_agent_state_before_reply: list[Callable | autogen.agentchat.contrib.swarm_agent.UPDATE_SYSTEM_MESSAGE] | Callable | autogen.agentchat.contrib.swarm_agent.UPDATE_SYSTEM_MESSAGE | None = None,
    **kwargs
)
```

    Swarm agent for participating in a swarm.
    
    SwarmAgent is a subclass of ConversableAgent.
    
    Additional args:
        functions (List[Callable]): A list of functions to register with the agent.
        update_agent_state_before_reply (List[Callable]): A list of functions, including UPDATE_SYSTEM_MESSAGEs, called to update the agent before it replies.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `name` | name of the agent.<br/><br/>**Type:** `str` |
| `system_message` | system message for the ChatCompletion inference.<br/><br/>**Type:** `str \| None`<br/><br/>**Default:** 'You are a helpful AI Assistant.' |
| `llm_config` | llm inference configuration.<br/><br/>Please refer to [OpenAIWrapper.create](/docs/reference/oai/client#create) for available options.<br/><br/>When using OpenAI or Azure OpenAI endpoints, please specify a non-empty 'model' either in `llm_config` or in each config of 'config_list' in `llm_config`.<br/><br/>To disable llm-based auto reply, set to False.<br/><br/>When set to None, will use self.DEFAULT_CONFIG, which defaults to False.<br/><br/>**Type:** `dict \| Literal[False] \| None`<br/><br/>**Default:** None |
| `functions` | **Type:** `list[typing.Callable] \| Callable`<br/><br/>**Default:** None |
| `is_termination_msg` | a function that takes a message in the form of a dictionary and returns a boolean value indicating if this received message is a termination message.<br/><br/>The dict can contain the following keys: "content", "role", "name", "function_call".<br/><br/>**Type:** `Callable[[dict], bool] \| None`<br/><br/>**Default:** None |
| `max_consecutive_auto_reply` | the maximum number of consecutive auto replies.<br/><br/>default to None (no limit provided, class attribute MAX_CONSECUTIVE_AUTO_REPLY will be used as the limit in this case).<br/><br/>When set to 0, no auto reply will be generated.<br/><br/>**Type:** `int \| None`<br/><br/>**Default:** None |
| `human_input_mode` | whether to ask for human inputs every time a message is received.<br/><br/>Possible values are "ALWAYS", "TERMINATE", "NEVER".<br/><br/>(1) When "ALWAYS", the agent prompts for human input every time a message is received.<br/><br/>Under this mode, the conversation stops when the human input is "exit", or when is_termination_msg is True and there is no human input.<br/><br/>(2) When "TERMINATE", the agent only prompts for human input only when a termination message is received or the number of auto reply reaches the max_consecutive_auto_reply.<br/><br/>(3) When "NEVER", the agent will never prompt for human input.<br/><br/>Under this mode, the conversation stops when the number of auto reply reaches the max_consecutive_auto_reply or when is_termination_msg is True.<br/><br/>**Type:** `Literal['ALWAYS', 'NEVER', 'TERMINATE']`<br/><br/>**Default:** 'NEVER' |
| `description` | a short description of the agent.<br/><br/>This description is used by other agents (e.g.<br/><br/>the GroupChatManager) to decide when to call upon this agent.<br/><br/>(Default: system_message)<br/><br/>**Type:** `str \| None`<br/><br/>**Default:** None |
| `code_execution_config=False` |  |
| `update_agent_state_before_reply` | **Type:** `list[Callable \| autogen.agentchat.contrib.swarm_agent.UPDATE_SYSTEM_MESSAGE] \| Callable \| autogen.agentchat.contrib.swarm_agent.UPDATE_SYSTEM_MESSAGE \| None`<br/><br/>**Default:** None |
| `**kwargs` |  |

### Static Methods

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### process_nested_chat_carryover
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmAgent.process_nested_chat_carryover" class="headerlink" title="Permanent link"></a>

```python
process_nested_chat_carryover(
    chat: dict[str, typing.Any],
    recipient: autogen.agentchat.conversable_agent.ConversableAgent,
    messages: list[dict[str, typing.Any]],
    sender: autogen.agentchat.conversable_agent.ConversableAgent,
    config: Any,
    trim_n_messages: int = 0
) -> None
```

    Process carryover messages for a nested chat (typically for the first chat of a swarm)
    
    The carryover_config key is a dictionary containing:
        "summary_method": The method to use to summarise the messages, can be "all", "last_msg", "reflection_with_llm" or a Callable
        "summary_args": Optional arguments for the summary method
    
    Supported carryover 'summary_methods' are:
        "all" - all messages will be incorporated
        "last_msg" - the last message will be incorporated
        "reflection_with_llm" - an llm will summarise all the messages and the summary will be incorporated as a single message
        Callable - a callable with the signature: my_method(agent: ConversableAgent, messages: List[Dict[str, Any]]) -> str

<b>Parameters:</b>
| Name | Description |
|--|--|
| `chat` | The chat dictionary containing the carryover configuration<br/><br/>**Type:** `dict[str, typing.Any]` |
| `recipient` | The recipient agent<br/><br/>**Type:** `autogen.agentchat.conversable_agent.ConversableAgent` |
| `messages` | The messages from the parent chat<br/><br/>**Type:** `list[dict[str, typing.Any]]` |
| `sender` | The sender agent<br/><br/>**Type:** `autogen.agentchat.conversable_agent.ConversableAgent` |
| `config` | **Type:** `Any` |
| `trim_n_messages` | The number of latest messages to trim from the messages list<br/><br/>**Type:** `int`<br/><br/>**Default:** 0 |

<br />

### Instance Methods

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### add_functions
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmAgent.add_functions" class="headerlink" title="Permanent link"></a>

```python
add_functions(self, func_list: list[typing.Callable]) -> 
```

    

<b>Parameters:</b>
| Name | Description |
|--|--|
| `func_list` | **Type:** `list[typing.Callable]` |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### add_single_function
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmAgent.add_single_function" class="headerlink" title="Permanent link"></a>

```python
add_single_function(
    self,
    func: Callable,
    name=None,
    description=''
) -> 
```

    Add a single function to the agent, removing context variables for LLM use

<b>Parameters:</b>
| Name | Description |
|--|--|
| `func` | **Type:** `Callable` |
| `name=None` |  |
| `description=''` |  |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### generate_swarm_tool_reply
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmAgent.generate_swarm_tool_reply" class="headerlink" title="Permanent link"></a>

```python
generate_swarm_tool_reply(
    self,
    messages: list[dict] | None = None,
    sender: autogen.agentchat.agent.Agent | None = None,
    config: autogen.oai.client.OpenAIWrapper | None = None
) -> tuple[bool, dict]
```

    Pre-processes and generates tool call replies.
    
    This function:
    1. Adds context_variables back to the tool call for the function, if necessary.
    2. Generates the tool calls reply.
    3. Updates context_variables and next_agent based on the tool call response.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `messages` | **Type:** `list[dict] \| None`<br/><br/>**Default:** None |
| `sender` | **Type:** `autogen.agentchat.agent.Agent \| None`<br/><br/>**Default:** None |
| `config` | **Type:** `autogen.oai.client.OpenAIWrapper \| None`<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### register_hand_off
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmAgent.register_hand_off" class="headerlink" title="Permanent link"></a>

```python
register_hand_off(self, hand_to: list[autogen.agentchat.contrib.swarm_agent.ON_CONDITION | autogen.agentchat.contrib.swarm_agent.AFTER_WORK] | autogen.agentchat.contrib.swarm_agent.ON_CONDITION | autogen.agentchat.contrib.swarm_agent.AFTER_WORK) -> 
```

    Register a function to hand off to another agent.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `hand_to` | A list of ON_CONDITIONs and an, optional, AFTER_WORK condition<br/><br/>**Type:** `list[autogen.agentchat.contrib.swarm_agent.ON_CONDITION \| autogen.agentchat.contrib.swarm_agent.AFTER_WORK] \| autogen.agentchat.contrib.swarm_agent.ON_CONDITION \| autogen.agentchat.contrib.swarm_agent.AFTER_WORK` |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### register_update_agent_state_before_reply
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmAgent.register_update_agent_state_before_reply" class="headerlink" title="Permanent link"></a>

```python
register_update_agent_state_before_reply(self, functions: list[typing.Callable] | Callable | None) -> 
```

    Register functions that will be called when the agent is selected and before it speaks.
    You can add your own validation or precondition functions here.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `functions` | A list of functions to be registered.<br/><br/>Each function is called when the agent is selected and before it speaks.<br/><br/>**Type:** `list[typing.Callable] \| Callable \| None` |

<br />

    <h2 id="autogen.agentchat.contrib.swarm_agent.SwarmResult" class="doc doc-heading">
        <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
        <span class="doc doc-object-name doc-class-name">SwarmResult</span>
        <a href="#autogen.agentchat.contrib.swarm_agent.SwarmResult" class="headerlink" title="Permanent link"></a>
    </h2>

```python
SwarmResult(**data: Any)
```

    Encapsulates the possible return values for a swarm agent function.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `**data` | **Type:** `Any` |

### Class Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### Config
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmResult.Config" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### agent
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmResult.agent" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### context_variables
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmResult.context_variables" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### model_config
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmResult.model_config" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### values
<a href="#autogen.agentchat.contrib.swarm_agent.SwarmResult.values" class="headerlink" title="Permanent link"></a>

    <br />

    <h2 id="autogen.agentchat.contrib.swarm_agent.UPDATE_SYSTEM_MESSAGE" class="doc doc-heading">
        <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
        <span class="doc doc-object-name doc-class-name">UPDATE_SYSTEM_MESSAGE</span>
        <a href="#autogen.agentchat.contrib.swarm_agent.UPDATE_SYSTEM_MESSAGE" class="headerlink" title="Permanent link"></a>
    </h2>

```python
UPDATE_SYSTEM_MESSAGE(update_function: str | Callable)
```

    Update the agent's system message before they reply

<b>Parameters:</b>
| Name | Description |
|--|--|
| `update_function` | The string or function to update the agent's system message.<br/><br/>Can be a string or a Callable.<br/><br/>If a string, it will be used as a template and substitute the context variables.<br/><br/>If a Callable, it should have the signature: def my_update_function(agent: ConversableAgent, messages: List[Dict[str, Any]]) -> str<br/><br/>**Type:** `str \| Callable` |

### Class Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### update_function
<a href="#autogen.agentchat.contrib.swarm_agent.UPDATE_SYSTEM_MESSAGE.update_function" class="headerlink" title="Permanent link"></a>

    <br />