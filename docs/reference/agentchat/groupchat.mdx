---
sidebarTitle: groupchat
title: autogen.agentchat.groupchat
---

    <h2 id="autogen.agentchat.groupchat.GroupChat" class="doc doc-heading">
        <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
        <span class="doc doc-object-name doc-class-name">GroupChat</span>
        <a href="#autogen.agentchat.groupchat.GroupChat" class="headerlink" title="Permanent link"></a>
    </h2>

```python
GroupChat(
    agents: list[autogen.agentchat.agent.Agent],
    messages: list[dict],
    max_round: int = 10,
    admin_name: str = 'Admin',
    func_call_filter: bool = True,
    speaker_selection_method: Literal['auto', 'manual', 'random', 'round_robin'] | Callable = 'auto',
    max_retries_for_selecting_speaker: int = 2,
    allow_repeat_speaker: bool | list[autogen.agentchat.agent.Agent] | None = None,
    allowed_or_disallowed_speaker_transitions: dict | None = None,
    speaker_transitions_type: Literal['allowed', 'disallowed', None] = None,
    enable_clear_history: bool = False,
    send_introductions: bool = False,
    select_speaker_message_template: str = 'You are in a role play game. The following roles are available:\n                \{roles}.\n                Read the following conversation.\n                Then select the next role from \{agentlist} to play. Only return the role.',
    select_speaker_prompt_template: str = 'Read the above conversation. Then select the next role from \{agentlist} to play. Only return the role.',
    select_speaker_auto_multiple_template: str = 'You provided more than one name in your text, please return just the name of the next speaker. To determine the speaker use these prioritised rules:\n    1. If the context refers to themselves as a speaker e.g. "As the..." , choose that speaker\'s name\n    2. If it refers to the "next" speaker name, choose that name\n    3. Otherwise, choose the first provided speaker\'s name in the context\n    The names are case-sensitive and should not be abbreviated or changed.\n    Respond with ONLY the name of the speaker and DO NOT provide a reason.',
    select_speaker_auto_none_template: str = 'You didn\'t choose a speaker. As a reminder, to determine the speaker use these prioritised rules:\n    1. If the context refers to themselves as a speaker e.g. "As the..." , choose that speaker\'s name\n    2. If it refers to the "next" speaker name, choose that name\n    3. Otherwise, choose the first provided speaker\'s name in the context\n    The names are case-sensitive and should not be abbreviated or changed.\n    The only names that are accepted are \{agentlist}.\n    Respond with ONLY the name of the speaker and DO NOT provide a reason.',
    select_speaker_transform_messages: autogen.agentchat.contrib.capabilities.transform_messages.TransformMessages | None = None,
    select_speaker_auto_verbose: bool | None = False,
    select_speaker_auto_model_client_cls: autogen.oai.client.ModelClient | list[autogen.oai.client.ModelClient] | None = None,
    select_speaker_auto_llm_config: dict | Literal[False] | None = None,
    role_for_select_speaker_messages: str | None = 'system'
)
```

    (In preview) A group chat class that contains the following data fields:
    - agents: a list of participating agents.
    - messages: a list of messages in the group chat.
    - max_round: the maximum number of rounds.
    - admin_name: the name of the admin agent if there is one. Default is "Admin".
        KeyBoardInterrupt will make the admin agent take over.
    - func_call_filter: whether to enforce function call filter. Default is True.
        When set to True and when a message is a function call suggestion,
        the next speaker will be chosen from an agent which contains the corresponding function name
        in its `function_map`.
    - select_speaker_message_template: customize the select speaker message (used in "auto" speaker selection), which appears first in the message context and generally includes the agent descriptions and list of agents. If the string contains "`\{roles}`" it will replaced with the agent's and their role descriptions. If the string contains "`\{agentlist}`" it will be replaced with a comma-separated list of agent names in square brackets. The default value is:
        "You are in a role play game. The following roles are available:
                `\{roles}`.
                Read the following conversation.
                Then select the next role from `\{agentlist}` to play. Only return the role."
    - select_speaker_prompt_template: customize the select speaker prompt (used in "auto" speaker selection), which appears last in the message context and generally includes the list of agents and guidance for the LLM to select the next agent. If the string contains "`\{agentlist}`" it will be replaced with a comma-separated list of agent names in square brackets. The default value is:
        "Read the above conversation. Then select the next role from `\{agentlist}` to play. Only return the role."
        To ignore this prompt being used, set this to None. If set to None, ensure your instructions for selecting a speaker are in the select_speaker_message_template string.
    - select_speaker_auto_multiple_template: customize the follow-up prompt used when selecting a speaker fails with a response that contains multiple agent names. This prompt guides the LLM to return just one agent name. Applies only to "auto" speaker selection method. If the string contains "`\{agentlist}`" it will be replaced with a comma-separated list of agent names in square brackets. The default value is:
        "You provided more than one name in your text, please return just the name of the next speaker. To determine the speaker use these prioritised rules:
                1. If the context refers to themselves as a speaker e.g. "As the..." , choose that speaker's name
                2. If it refers to the "next" speaker name, choose that name
                3. Otherwise, choose the first provided speaker's name in the context
                The names are case-sensitive and should not be abbreviated or changed.
                Respond with ONLY the name of the speaker and DO NOT provide a reason."
    - select_speaker_auto_none_template: customize the follow-up prompt used when selecting a speaker fails with a response that contains no agent names. This prompt guides the LLM to return an agent name and provides a list of agent names. Applies only to "auto" speaker selection method. If the string contains "`\{agentlist}`" it will be replaced with a comma-separated list of agent names in square brackets. The default value is:
        "You didn't choose a speaker. As a reminder, to determine the speaker use these prioritised rules:
                1. If the context refers to themselves as a speaker e.g. "As the..." , choose that speaker's name
                2. If it refers to the "next" speaker name, choose that name
                3. Otherwise, choose the first provided speaker's name in the context
                The names are case-sensitive and should not be abbreviated or changed.
                The only names that are accepted are `\{agentlist}`.
                Respond with ONLY the name of the speaker and DO NOT provide a reason."
    - speaker_selection_method: the method for selecting the next speaker. Default is "auto".
        Could be any of the following (case insensitive), will raise ValueError if not recognized:
        - "auto": the next speaker is selected automatically by LLM.
        - "manual": the next speaker is selected manually by user input.
        - "random": the next speaker is selected randomly.
        - "round_robin": the next speaker is selected in a round robin fashion, i.e., iterating in the same order as provided in `agents`.
        - a customized speaker selection function (Callable): the function will be called to select the next speaker.
            The function should take the last speaker and the group chat as input and return one of the following:
                1. an `Agent` class, it must be one of the agents in the group chat.
                2. a string from ['auto', 'manual', 'random', 'round_robin'] to select a default method to use.
                3. None, which would terminate the conversation gracefully.
            ```python
            def custom_speaker_selection_func(
                last_speaker: Agent, groupchat: GroupChat
            ) -> Union[Agent, str, None]:
            ```
    - max_retries_for_selecting_speaker: the maximum number of times the speaker selection requery process will run.
        If, during speaker selection, multiple agent names or no agent names are returned by the LLM as the next agent, it will be queried again up to the maximum number
        of times until a single agent is returned or it exhausts the maximum attempts.
        Applies only to "auto" speaker selection method.
        Default is 2.
    - select_speaker_transform_messages: (optional) the message transformations to apply to the nested select speaker agent-to-agent chat messages.
        Takes a TransformMessages object, defaults to None and is only utilised when the speaker selection method is "auto".
    - select_speaker_auto_verbose: whether to output the select speaker responses and selections
        If set to True, the outputs from the two agents in the nested select speaker chat will be output, along with
        whether the responses were successful, or not, in selecting an agent
        Applies only to "auto" speaker selection method.
    - allow_repeat_speaker: whether to allow the same speaker to speak consecutively.
        Default is True, in which case all speakers are allowed to speak consecutively.
        If `allow_repeat_speaker` is a list of Agents, then only those listed agents are allowed to repeat.
        If set to False, then no speakers are allowed to repeat.
        `allow_repeat_speaker` and `allowed_or_disallowed_speaker_transitions` are mutually exclusive.
    - allowed_or_disallowed_speaker_transitions: dict.
        The keys are source agents, and the values are agents that the key agent can/can't transit to,
        depending on speaker_transitions_type. Default is None, which means all agents can transit to all other agents.
        `allow_repeat_speaker` and `allowed_or_disallowed_speaker_transitions` are mutually exclusive.
    - speaker_transitions_type: whether the speaker_transitions_type is a dictionary containing lists of allowed agents or disallowed agents.
        "allowed" means the `allowed_or_disallowed_speaker_transitions` is a dictionary containing lists of allowed agents.
        If set to "disallowed", then the `allowed_or_disallowed_speaker_transitions` is a dictionary containing lists of disallowed agents.
        Must be supplied if `allowed_or_disallowed_speaker_transitions` is not None.
    - enable_clear_history: enable possibility to clear history of messages for agents manually by providing
        "clear history" phrase in user prompt. This is experimental feature.
        See description of GroupChatManager.clear_agents_history function for more info.
    - send_introductions: send a round of introductions at the start of the group chat, so agents know who they can speak to (default: False)
    - select_speaker_auto_model_client_cls: Custom model client class for the internal speaker select agent used during 'auto' speaker selection (optional)
    - select_speaker_auto_llm_config: LLM config for the internal speaker select agent used during 'auto' speaker selection (optional)
    - role_for_select_speaker_messages: sets the role name for speaker selection when in 'auto' mode, typically 'user' or 'system'. (default: 'system')

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** `list[autogen.agentchat.agent.Agent]` |
| `messages` | **Type:** `list[dict]` |
| `max_round` | **Type:** `int`<br/><br/>**Default:** 10 |
| `admin_name` | **Type:** `str`<br/><br/>**Default:** 'Admin' |
| `func_call_filter` | **Type:** `bool`<br/><br/>**Default:** True |
| `speaker_selection_method` | **Type:** `Literal['auto', 'manual', 'random', 'round_robin'] \| Callable`<br/><br/>**Default:** 'auto' |
| `max_retries_for_selecting_speaker` | **Type:** `int`<br/><br/>**Default:** 2 |
| `allow_repeat_speaker` | **Type:** `bool \| list[autogen.agentchat.agent.Agent] \| None`<br/><br/>**Default:** None |
| `allowed_or_disallowed_speaker_transitions` | **Type:** `dict \| None`<br/><br/>**Default:** None |
| `speaker_transitions_type` | **Type:** `Literal['allowed', 'disallowed', None]`<br/><br/>**Default:** None |
| `enable_clear_history` | **Type:** `bool`<br/><br/>**Default:** False |
| `send_introductions` | **Type:** `bool`<br/><br/>**Default:** False |
| `select_speaker_message_template` | **Type:** `str`<br/><br/>**Default:** 'You are in a role play game. The following roles are available |
| `select_speaker_prompt_template` | **Type:** `str`<br/><br/>**Default:** 'Read the above conversation. Then select the next role from \{agentlist} to play. Only return the role.' |
| `select_speaker_auto_multiple_template` | **Type:** `str`<br/><br/>**Default:** 'You provided more than one name in your text, please return just the name of the next speaker. To determine the speaker use these prioritised rules |
| `select_speaker_auto_none_template` | **Type:** `str`<br/><br/>**Default:** 'You didn\'t choose a speaker. As a reminder, to determine the speaker use these prioritised rules |
| `select_speaker_transform_messages` | **Type:** `autogen.agentchat.contrib.capabilities.transform_messages.TransformMessages \| None`<br/><br/>**Default:** None |
| `select_speaker_auto_verbose` | **Type:** `bool \| None`<br/><br/>**Default:** False |
| `select_speaker_auto_model_client_cls` | **Type:** `autogen.oai.client.ModelClient \| list[autogen.oai.client.ModelClient] \| None`<br/><br/>**Default:** None |
| `select_speaker_auto_llm_config` | **Type:** `dict \| Literal[False] \| None`<br/><br/>**Default:** None |
| `role_for_select_speaker_messages` | **Type:** `str \| None`<br/><br/>**Default:** 'system' |

### Class Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### DEFAULT_INTRO_MSG
<a href="#autogen.agentchat.groupchat.GroupChat.DEFAULT_INTRO_MSG" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### admin_name
<a href="#autogen.agentchat.groupchat.GroupChat.admin_name" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### agents
<a href="#autogen.agentchat.groupchat.GroupChat.agents" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### allow_repeat_speaker
<a href="#autogen.agentchat.groupchat.GroupChat.allow_repeat_speaker" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### allowed_or_disallowed_speaker_transitions
<a href="#autogen.agentchat.groupchat.GroupChat.allowed_or_disallowed_speaker_transitions" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### allowed_speaker_transitions_dict
<a href="#autogen.agentchat.groupchat.GroupChat.allowed_speaker_transitions_dict" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### enable_clear_history
<a href="#autogen.agentchat.groupchat.GroupChat.enable_clear_history" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### func_call_filter
<a href="#autogen.agentchat.groupchat.GroupChat.func_call_filter" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### max_retries_for_selecting_speaker
<a href="#autogen.agentchat.groupchat.GroupChat.max_retries_for_selecting_speaker" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### max_round
<a href="#autogen.agentchat.groupchat.GroupChat.max_round" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### messages
<a href="#autogen.agentchat.groupchat.GroupChat.messages" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### role_for_select_speaker_messages
<a href="#autogen.agentchat.groupchat.GroupChat.role_for_select_speaker_messages" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_llm_config
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_auto_llm_config" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_model_client_cls
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_auto_model_client_cls" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_multiple_template
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_auto_multiple_template" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_none_template
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_auto_none_template" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_verbose
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_auto_verbose" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_message_template
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_message_template" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_prompt_template
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_prompt_template" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_transform_messages
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_transform_messages" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### send_introductions
<a href="#autogen.agentchat.groupchat.GroupChat.send_introductions" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### speaker_selection_method
<a href="#autogen.agentchat.groupchat.GroupChat.speaker_selection_method" class="headerlink" title="Permanent link"></a>

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### speaker_transitions_type
<a href="#autogen.agentchat.groupchat.GroupChat.speaker_transitions_type" class="headerlink" title="Permanent link"></a>

    <br />

### Instance Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### agent_names
<a href="#autogen.agentchat.groupchat.GroupChat.agent_names" class="headerlink" title="Permanent link"></a>

    Return the names of the agents in the group chat.

### Instance Methods

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### a_auto_select_speaker
<a href="#autogen.agentchat.groupchat.GroupChat.a_auto_select_speaker" class="headerlink" title="Permanent link"></a>

```python
a_auto_select_speaker(
    self,
    last_speaker: autogen.agentchat.agent.Agent,
    selector: autogen.agentchat.conversable_agent.ConversableAgent,
    messages: list[dict] | None,
    agents: list[autogen.agentchat.agent.Agent] | None
) -> autogen.agentchat.agent.Agent
```

    (Asynchronous) Selects next speaker for the "auto" speaker selection method. Utilises its own two-agent chat to determine the next speaker and supports requerying.
    
    Speaker selection for "auto" speaker selection method:
    1. Create a two-agent chat with a speaker selector agent and a speaker validator agent, like a nested chat
    2. Inject the group messages into the new chat
    3. Run the two-agent chat, evaluating the result of response from the speaker selector agent:
        - If a single agent is provided then we return it and finish. If not, we add an additional message to this nested chat in an attempt to guide the LLM to a single agent response
    4. Chat continues until a single agent is nominated or there are no more attempts left
    5. If we run out of turns and no single agent can be determined, the next speaker in the list of agents is returned

<b>Parameters:</b>
| Name | Description |
|--|--|
| `last_speaker` | **Type:** `autogen.agentchat.agent.Agent` |
| `selector` | **Type:** `autogen.agentchat.conversable_agent.ConversableAgent` |
| `messages` | **Type:** `list[dict] \| None` |
| `agents` | **Type:** `list[autogen.agentchat.agent.Agent] \| None` |

<b>Returns:</b>
| Type | Description |
|--|--|
| `autogen.agentchat.agent.Agent` | Dict: a counter for mentioned agents. |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### a_select_speaker
<a href="#autogen.agentchat.groupchat.GroupChat.a_select_speaker" class="headerlink" title="Permanent link"></a>

```python
a_select_speaker(
    self,
    last_speaker: autogen.agentchat.agent.Agent,
    selector: autogen.agentchat.conversable_agent.ConversableAgent
) -> autogen.agentchat.agent.Agent
```

    Select the next speaker (with requery), asynchronously.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `last_speaker` | **Type:** `autogen.agentchat.agent.Agent` |
| `selector` | **Type:** `autogen.agentchat.conversable_agent.ConversableAgent` |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### agent_by_name
<a href="#autogen.agentchat.groupchat.GroupChat.agent_by_name" class="headerlink" title="Permanent link"></a>

```python
agent_by_name(
    self,
    name: str,
    recursive: bool = False,
    raise_on_name_conflict: bool = False
) -> autogen.agentchat.agent.Agent | None
```

    Returns the agent with a given name. If recursive is True, it will search in nested teams.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `name` | **Type:** `str` |
| `recursive` | **Type:** `bool`<br/><br/>**Default:** False |
| `raise_on_name_conflict` | **Type:** `bool`<br/><br/>**Default:** False |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### append
<a href="#autogen.agentchat.groupchat.GroupChat.append" class="headerlink" title="Permanent link"></a>

```python
append(
    self,
    message: dict,
    speaker: autogen.agentchat.agent.Agent
) -> 
```

    Append a message to the group chat.
    We cast the content to str here so that it can be managed by text-based
    model.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `message` | **Type:** `dict` |
| `speaker` | **Type:** `autogen.agentchat.agent.Agent` |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### introductions_msg
<a href="#autogen.agentchat.groupchat.GroupChat.introductions_msg" class="headerlink" title="Permanent link"></a>

```python
introductions_msg(self, agents: list[autogen.agentchat.agent.Agent] | None = None) -> str
```

    Return the system message for selecting the next speaker. This is always the *first* message in the context.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** `list[autogen.agentchat.agent.Agent] \| None`<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### manual_select_speaker
<a href="#autogen.agentchat.groupchat.GroupChat.manual_select_speaker" class="headerlink" title="Permanent link"></a>

```python
manual_select_speaker(self, agents: list[autogen.agentchat.agent.Agent] | None = None) -> autogen.agentchat.agent.Agent | None
```

    Manually select the next speaker.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** `list[autogen.agentchat.agent.Agent] \| None`<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### nested_agents
<a href="#autogen.agentchat.groupchat.GroupChat.nested_agents" class="headerlink" title="Permanent link"></a>

```python
nested_agents(self) -> list[autogen.agentchat.agent.Agent]
```

    Returns all agents in the group chat manager.

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### next_agent
<a href="#autogen.agentchat.groupchat.GroupChat.next_agent" class="headerlink" title="Permanent link"></a>

```python
next_agent(
    self,
    agent: autogen.agentchat.agent.Agent,
    agents: list[autogen.agentchat.agent.Agent] | None = None
) -> autogen.agentchat.agent.Agent
```

    Return the next agent in the list.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agent` | **Type:** `autogen.agentchat.agent.Agent` |
| `agents` | **Type:** `list[autogen.agentchat.agent.Agent] \| None`<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### random_select_speaker
<a href="#autogen.agentchat.groupchat.GroupChat.random_select_speaker" class="headerlink" title="Permanent link"></a>

```python
random_select_speaker(self, agents: list[autogen.agentchat.agent.Agent] | None = None) -> autogen.agentchat.agent.Agent | None
```

    Randomly select the next speaker.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** `list[autogen.agentchat.agent.Agent] \| None`<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### reset
<a href="#autogen.agentchat.groupchat.GroupChat.reset" class="headerlink" title="Permanent link"></a>

```python
reset(self) -> 
```

    Reset the group chat.

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### select_speaker
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker" class="headerlink" title="Permanent link"></a>

```python
select_speaker(
    self,
    last_speaker: autogen.agentchat.agent.Agent,
    selector: autogen.agentchat.conversable_agent.ConversableAgent
) -> autogen.agentchat.agent.Agent
```

    Select the next speaker (with requery).

<b>Parameters:</b>
| Name | Description |
|--|--|
| `last_speaker` | **Type:** `autogen.agentchat.agent.Agent` |
| `selector` | **Type:** `autogen.agentchat.conversable_agent.ConversableAgent` |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### select_speaker_msg
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_msg" class="headerlink" title="Permanent link"></a>

```python
select_speaker_msg(self, agents: list[autogen.agentchat.agent.Agent] | None = None) -> str
```

    Return the system message for selecting the next speaker. This is always the *first* message in the context.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** `list[autogen.agentchat.agent.Agent] \| None`<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### select_speaker_prompt
<a href="#autogen.agentchat.groupchat.GroupChat.select_speaker_prompt" class="headerlink" title="Permanent link"></a>

```python
select_speaker_prompt(self, agents: list[autogen.agentchat.agent.Agent] | None = None) -> str
```

    Return the floating system prompt selecting the next speaker.
    This is always the *last* message in the context.
    Will return None if the select_speaker_prompt_template is None.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** `list[autogen.agentchat.agent.Agent] \| None`<br/><br/>**Default:** None |

<br />

    <h2 id="autogen.agentchat.groupchat.GroupChatManager" class="doc doc-heading">
        <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
        <span class="doc doc-object-name doc-class-name">GroupChatManager</span>
        <a href="#autogen.agentchat.groupchat.GroupChatManager" class="headerlink" title="Permanent link"></a>
    </h2>

```python
GroupChatManager(
    groupchat: autogen.agentchat.groupchat.GroupChat,
    name: str | None = 'chat_manager',
    max_consecutive_auto_reply: int | None = 9223372036854775807,
    human_input_mode: Literal['ALWAYS', 'NEVER', 'TERMINATE'] = 'NEVER',
    system_message: str | list | None = 'Group chat manager.',
    silent: bool = False,
    **kwargs
)
```

    (In preview) A chat manager agent that can manage a group chat of multiple agents.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `groupchat` | **Type:** `autogen.agentchat.groupchat.GroupChat` |
| `name` | name of the agent.<br/><br/>**Type:** `str \| None`<br/><br/>**Default:** 'chat_manager' |
| `max_consecutive_auto_reply` | the maximum number of consecutive auto replies.<br/><br/>default to None (no limit provided, class attribute MAX_CONSECUTIVE_AUTO_REPLY will be used as the limit in this case).<br/><br/>When set to 0, no auto reply will be generated.<br/><br/>**Type:** `int \| None`<br/><br/>**Default:** 9223372036854775807 |
| `human_input_mode` | whether to ask for human inputs every time a message is received.<br/><br/>Possible values are "ALWAYS", "TERMINATE", "NEVER".<br/><br/>(1) When "ALWAYS", the agent prompts for human input every time a message is received.<br/><br/>Under this mode, the conversation stops when the human input is "exit", or when is_termination_msg is True and there is no human input.<br/><br/>(2) When "TERMINATE", the agent only prompts for human input only when a termination message is received or the number of auto reply reaches the max_consecutive_auto_reply.<br/><br/>(3) When "NEVER", the agent will never prompt for human input.<br/><br/>Under this mode, the conversation stops when the number of auto reply reaches the max_consecutive_auto_reply or when is_termination_msg is True.<br/><br/>**Type:** `Literal['ALWAYS', 'NEVER', 'TERMINATE']`<br/><br/>**Default:** 'NEVER' |
| `system_message` | system message for the ChatCompletion inference.<br/><br/>**Type:** `str \| list \| None`<br/><br/>**Default:** 'Group chat manager.' |
| `silent` | (Experimental) whether to print the message sent.<br/><br/>If None, will use the value of silent in each function.<br/><br/>**Type:** `bool`<br/><br/>**Default:** False |
| `**kwargs` |  |

### Instance Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### groupchat
<a href="#autogen.agentchat.groupchat.GroupChatManager.groupchat" class="headerlink" title="Permanent link"></a>

    Returns the group chat managed by the group chat manager.

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### last_speaker
<a href="#autogen.agentchat.groupchat.GroupChatManager.last_speaker" class="headerlink" title="Permanent link"></a>

    Return the agent who sent the last message to group chat manager.
    
    In a group chat, an agent will always send a message to the group chat manager, and the group chat manager will
    send the message to all other agents in the group chat. So, when an agent receives a message, it will always be
    from the group chat manager. With this property, the agent receiving the message can know who actually sent the
    message.
    
    Example:
    ```python
    from autogen import ConversableAgent
    from autogen import GroupChat, GroupChatManager
    
    
    def print_messages(recipient, messages, sender, config):
        # Print the message immediately
        print(f"Sender: \{sender.name} | Recipient: \{recipient.name} | Message: \{messages[-1].get('content')}")
        print(f"Real Sender: \{sender.last_speaker.name}")
        assert sender.last_speaker.name in messages[-1].get("content")
        return False, None  # Required to ensure the agent communication flow continues
    
    
    agent_a = ConversableAgent("agent A", default_auto_reply="I'm agent A.")
    agent_b = ConversableAgent("agent B", default_auto_reply="I'm agent B.")
    agent_c = ConversableAgent("agent C", default_auto_reply="I'm agent C.")
    for agent in [agent_a, agent_b, agent_c]:
        agent.register_reply([ConversableAgent, None], reply_func=print_messages, config=None)
    group_chat = GroupChat(
        [agent_a, agent_b, agent_c],
        messages=[],
        max_round=6,
        speaker_selection_method="random",
        allow_repeat_speaker=True,
    )
    chat_manager = GroupChatManager(group_chat)
    groupchat_result = agent_a.initiate_chat(chat_manager, message="Hi, there, I'm agent A.")
    ```

### Instance Methods

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### a_resume
<a href="#autogen.agentchat.groupchat.GroupChatManager.a_resume" class="headerlink" title="Permanent link"></a>

```python
a_resume(
    self,
    messages: list[dict] | str,
    remove_termination_string: str | Callable[[str], str] | None = None,
    silent: bool | None = False
) -> tuple[autogen.agentchat.conversable_agent.ConversableAgent, dict]
```

    Resumes a group chat using the previous messages as a starting point, asynchronously. Requires the agents, group chat, and group chat manager to be established
    as per the original group chat.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `messages` | **Type:** `list[dict] \| str` |
| `remove_termination_string` | **Type:** `str \| Callable[[str], str] \| None`<br/><br/>**Default:** None |
| `silent` | **Type:** `bool \| None`<br/><br/>**Default:** False |

<b>Returns:</b>
| Type | Description |
|--|--|
| `tuple[autogen.agentchat.conversable_agent.ConversableAgent, dict]` | - Tuple[ConversableAgent, Dict]: A tuple containing the last agent who spoke and their message |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### a_run_chat
<a href="#autogen.agentchat.groupchat.GroupChatManager.a_run_chat" class="headerlink" title="Permanent link"></a>

```python
a_run_chat(
    self,
    messages: list[dict] | None = None,
    sender: autogen.agentchat.agent.Agent | None = None,
    config: autogen.agentchat.groupchat.GroupChat | None = None
) -> 
```

    Run a group chat asynchronously.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `messages` | **Type:** `list[dict] \| None`<br/><br/>**Default:** None |
| `sender` | **Type:** `autogen.agentchat.agent.Agent \| None`<br/><br/>**Default:** None |
| `config` | **Type:** `autogen.agentchat.groupchat.GroupChat \| None`<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### chat_messages_for_summary
<a href="#autogen.agentchat.groupchat.GroupChatManager.chat_messages_for_summary" class="headerlink" title="Permanent link"></a>

```python
chat_messages_for_summary(self, agent: autogen.agentchat.agent.Agent) -> list[dict]
```

    The list of messages in the group chat as a conversation to summarize.
    The agent is ignored.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agent` | **Type:** `autogen.agentchat.agent.Agent` |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### clear_agents_history
<a href="#autogen.agentchat.groupchat.GroupChatManager.clear_agents_history" class="headerlink" title="Permanent link"></a>

```python
clear_agents_history(
    self,
    reply: dict,
    groupchat: autogen.agentchat.groupchat.GroupChat
) -> str
```

    Clears history of messages for all agents or selected one. Can preserve selected number of last messages.
    That function is called when user manually provide "clear history" phrase in his reply.
    When "clear history" is provided, the history of messages for all agents is cleared.
    When "clear history `&lt;agent_name>`" is provided, the history of messages for selected agent is cleared.
    When "clear history `&lt;nr_of_messages_to_preserve>`" is provided, the history of messages for all agents is cleared
    except last `&lt;nr_of_messages_to_preserve>` messages.
    When "clear history `&lt;agent_name>` `&lt;nr_of_messages_to_preserve>`" is provided, the history of messages for selected
    agent is cleared except last `&lt;nr_of_messages_to_preserve>` messages.
    Phrase "clear history" and optional arguments are cut out from the reply before it passed to the chat.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `reply` | reply message dict to analyze.<br/><br/>**Type:** `dict` |
| `groupchat` | GroupChat object.<br/><br/>**Type:** `autogen.agentchat.groupchat.GroupChat` |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### messages_from_string
<a href="#autogen.agentchat.groupchat.GroupChatManager.messages_from_string" class="headerlink" title="Permanent link"></a>

```python
messages_from_string(self, message_string: str) -> list[dict]
```

    Reads the saved state of messages in Json format for resume and returns as a messages list

<b>Parameters:</b>
| Name | Description |
|--|--|
| `message_string` | **Type:** `str` |

<b>Returns:</b>
| Type | Description |
|--|--|
| `list[dict]` | - List[Dict]: List of messages |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### messages_to_string
<a href="#autogen.agentchat.groupchat.GroupChatManager.messages_to_string" class="headerlink" title="Permanent link"></a>

```python
messages_to_string(self, messages: list[dict]) -> str
```

    Converts the provided messages into a Json string that can be used for resuming the chat.
    The state is made up of a list of messages

<b>Parameters:</b>
| Name | Description |
|--|--|
| `messages` | **Type:** `list[dict]` |

<b>Returns:</b>
| Type | Description |
|--|--|
| `str` | - str: Json representation of the messages which can be persisted for resuming later |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### resume
<a href="#autogen.agentchat.groupchat.GroupChatManager.resume" class="headerlink" title="Permanent link"></a>

```python
resume(
    self,
    messages: list[dict] | str,
    remove_termination_string: str | Callable[[str], str] | None = None,
    silent: bool | None = False
) -> tuple[autogen.agentchat.conversable_agent.ConversableAgent, dict]
```

    Resumes a group chat using the previous messages as a starting point. Requires the agents, group chat, and group chat manager to be established
    as per the original group chat.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `messages` | **Type:** `list[dict] \| str` |
| `remove_termination_string` | **Type:** `str \| Callable[[str], str] \| None`<br/><br/>**Default:** None |
| `silent` | **Type:** `bool \| None`<br/><br/>**Default:** False |

<b>Returns:</b>
| Type | Description |
|--|--|
| `tuple[autogen.agentchat.conversable_agent.ConversableAgent, dict]` | - Tuple[ConversableAgent, Dict]: A tuple containing the last agent who spoke and their message |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### run_chat
<a href="#autogen.agentchat.groupchat.GroupChatManager.run_chat" class="headerlink" title="Permanent link"></a>

```python
run_chat(
    self,
    messages: list[dict] | None = None,
    sender: autogen.agentchat.agent.Agent | None = None,
    config: autogen.agentchat.groupchat.GroupChat | None = None
) -> tuple[bool, str | None]
```

    Run a group chat.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `messages` | **Type:** `list[dict] \| None`<br/><br/>**Default:** None |
| `sender` | **Type:** `autogen.agentchat.agent.Agent \| None`<br/><br/>**Default:** None |
| `config` | **Type:** `autogen.agentchat.groupchat.GroupChat \| None`<br/><br/>**Default:** None |

<br />